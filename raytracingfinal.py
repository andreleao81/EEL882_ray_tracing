# -*- coding: utf-8 -*-
"""RayTracingFinal.ipynb

Automatically generated by Colab.

Original file is located at
"""

import numpy as np
import cv2
from google.colab.patches import cv2_imshow

# Vector operations using NumPy
def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm

def sphere_intersection(center, radius, ray_origin, ray_direction):
    oc = ray_origin - center
    a = np.dot(ray_direction, ray_direction)
    b = 2.0 * np.dot(oc, ray_direction)
    c = np.dot(oc, oc) - radius * radius
    discriminant = b * b - 4 * a * c
    if discriminant < 0:
        return False, None
    else:
        t = (-b - np.sqrt(discriminant)) / (2.0 * a)
        if t < 0:
            t = (-b + np.sqrt(discriminant)) / (2.0 * a)
        return t >= 0, t

def compute_color(ray_origin, ray_direction, light_position, max_depth, spheres):
    closest_t = float('inf')
    hit_sphere = None

    for sphere in spheres:
        hit, t = sphere_intersection(sphere['center'], sphere['radius'], ray_origin, ray_direction)
        if hit and t < closest_t:
            closest_t = t
            hit_sphere = sphere

    if hit_sphere is None:
        return np.array([0, 0, 0])

    hit_point = ray_origin + closest_t * ray_direction
    normal = normalize(hit_point - hit_sphere['center'])
    light_dir = normalize(light_position - hit_point)
    diffuse = max(0.0, np.dot(normal, light_dir))
    diffuse_color = hit_sphere['color'] * diffuse
    ambient_color = hit_sphere['color'] * hit_sphere['ambient_intensity']

    return 0.5 * (ambient_color + diffuse_color) * np.array([1.5, 1.5, 1.5])

def render_image():
    image_width = 1600
    image_height = 800
    max_depth = 1

    light_position = np.array([1, 0, 0])
    image = np.zeros((image_height, image_width, 3), dtype=np.uint8)

    camera_origin = np.array([0, 0, 0])
    viewport_width = np.array([4, 0, 0])
    viewport_height = np.array([0, 2, 0])
    lower_left_corner = np.array([-2, -1, -1])

    spheres = [
        {'center': np.array([-1, 0, -1]), 'radius': 0.5, 'color': np.array([1, 0, 0]), 'ambient_intensity': 0.1},
        {'center': np.array([1, 0, -1]), 'radius': 0.5, 'color': np.array([0, 1, 0]), 'ambient_intensity': 0.1},
        {'center': np.array([0, -100.5, -1]), 'radius': 100, 'color': np.array([0.5, 0.5, 0.5]), 'ambient_intensity': 0.1}
    ]

    for j in range(image_height):
        for i in range(image_width):
            u = i / (image_width - 1)
            v = j / (image_height - 1)
            ray_direction = normalize(lower_left_corner + u * viewport_width + v * viewport_height - camera_origin)
            color = compute_color(camera_origin, ray_direction, light_position, max_depth, spheres)
            image[image_height - j - 1, i] = [int(255.999 * color[2]), int(255.999 * color[1]), int(255.999 * color[0])]

    cv2_imshow(image)
    cv2.imwrite("output.png", image)

if __name__ == "__main__":
    render_image()